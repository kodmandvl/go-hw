package main

import (
	"errors"
	"fmt"
	"math/rand"
	"sync"
	"sync/atomic"
	"time"
)

var ErrErrorsLimitExceeded = errors.New("errors limit exceeded")

type Task func() error

// Run starts tasks in n goroutines and stops its work when receiving m errors from tasks.
func Run(tasks []Task, n, m int) error {
	if m <= 0 {
		// Значение m <= 0 трактуется на усмотрение программиста. Выбираем вариант:
		// считать это как "максимум 0 ошибок", значит функция всегда будет возвращать ErrErrorsLimitExceeded;
		return ErrErrorsLimitExceeded
	}

	wg := sync.WaitGroup{}  // WaitGroup для n горутин и ожидания их завершения
	lockCnt := sync.Mutex{} // Mutex для защиты счётчика ошибок
	lockInd := sync.Mutex{} // Mutex для защиты индекса выбираемых тасок
	var cnt int             // счётчик ошибок
	var ind int             // глобальный безопасный индекс для выполняемых тасок, выбираемых из слайса
	tLen := len(tasks)      // размер слайса тасков (чтобы не вычислять его каждый раз, когда он понадобится)

	// Цикл запуска n горутин:
	for i := 0; i < n; i++ {
		wg.Add(1) // Добавляем в WaitGroup
		go func() {
			defer wg.Done() // Через defer в конце выполнения i-ой горутины уменьшаем счётчик WaitGroup
			// Получаем таски из слайса тасков:
			for {
				// Манипуляции с индексом слайса проводим под защитой (через mutex):
				lockInd.Lock()
				i := ind
				ind++
				lockInd.Unlock()
				if i >= tLen {
					return
				}
				// Манипуляции со счётчиком ошибок проводим под защитой (через mutex):
				lockCnt.Lock()
				if cnt >= m {
					lockCnt.Unlock()
					return
				}
				lockCnt.Unlock()
				e := tasks[i]()
				lockCnt.Lock()
				if e != nil {
					cnt++
				}
				lockCnt.Unlock()
			}
		}()
	}

	wg.Wait() // Ожидание окончания выполнения n горутин

	// Если было превышено m, возвращаем ошибку ErrErrorsLimitExceeded:
	if cnt >= m {
		return ErrErrorsLimitExceeded
	}

	// Если ранее не вышли из функции, вернув ErrErrorsLimitExceeded, то всё хорошо, возвращаем nil:
	return nil
}

func main() {
	fmt.Println("========== TEST 1. if were errors in first M tasks, than finished not more N+M tasks ==========")
	tasksCount1 := 50
	tasks1 := make([]Task, 0, tasksCount1)

	var runTasksCount1 int32

	for i := 0; i < tasksCount1; i++ {
		err := fmt.Errorf("error from task %d", i)
		tasks1 = append(tasks1, func() error {
			time.Sleep(time.Millisecond * time.Duration(rand.Intn(100)))
			atomic.AddInt32(&runTasksCount1, 1)
			fmt.Println("error:", err)
			return err
		})
	}

	workersCount1 := 10
	maxErrorsCount1 := 3
	err1 := Run(tasks1, workersCount1, maxErrorsCount1)
	if err1 != nil {
		fmt.Println("error:", err1)
	}

	fmt.Println("========== TEST 2. tasks without errors ==========")
	tasksCount2 := 50
	tasks2 := make([]Task, 0, tasksCount2)

	var runTasksCount2 int32
	var sumTime2 time.Duration

	for i := 0; i < tasksCount2; i++ {
		taskSleep := time.Millisecond * time.Duration(rand.Intn(100))
		sumTime2 += taskSleep

		tasks2 = append(tasks2, func() error {
			time.Sleep(taskSleep)
			atomic.AddInt32(&runTasksCount2, 1)
			return nil
		})
	}

	workersCount2 := 5
	maxErrorsCount2 := 1

	start := time.Now()
	err2 := Run(tasks2, workersCount2, maxErrorsCount2)
	elapsedTime2 := time.Since(start)
	if err2 == nil {
		fmt.Println("OK")
	}
	fmt.Println("TASKS COUNT:", tasksCount2)
	fmt.Println("RUN TASKS COUNT:", runTasksCount2)
	fmt.Println("(all tasks must be completed)")
	fmt.Println("ELAPSED TIME:", elapsedTime2)
	fmt.Println("SUM TIME:", sumTime2)
	fmt.Println("(elapsed time must be less or equal than one half of sum time)")
}
